@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)

import kotlinx.cinterop.*
import platform.windows.*
import msimg32.*   // Generated by cinterop: GradientFill, TRIVERTEX, GRADIENT_TRIANGLE, etc.

private const val CLASS_NAME = "WindowClass"
private const val WINDOW_NAME = "Hello, World!"

// Draw a vertex-colored (RGB) gradient triangle using msimg32!GradientFill.
private fun drawTriangle(hdc: HDC?, width: Int, height: Int) = memScoped {
    // Allocate 3 TRIVERTEX entries on the native stack (valid only within this memScoped block).
    val v = allocArray<TRIVERTEX>(3)

    // Vertex 0: top (red)
    v[0].x = (width * 1 / 2)
    v[0].y = (height * 1 / 4)
    v[0].Red = 0xFFFF.toUShort()
    v[0].Green = 0x0000.toUShort()
    v[0].Blue = 0x0000.toUShort()
    v[0].Alpha = 0x0000.toUShort()

    // Vertex 1: bottom-right (green)
    v[1].x = (width * 3 / 4)
    v[1].y = (height * 3 / 4)
    v[1].Red = 0x0000.toUShort()
    v[1].Green = 0xFFFF.toUShort()
    v[1].Blue = 0x0000.toUShort()
    v[1].Alpha = 0x0000.toUShort()

    // Vertex 2: bottom-left (blue)
    v[2].x = (width * 1 / 4)
    v[2].y = (height * 3 / 4)
    v[2].Red = 0x0000.toUShort()
    v[2].Green = 0x0000.toUShort()
    v[2].Blue = 0xFFFF.toUShort()
    v[2].Alpha = 0x0000.toUShort()

    // GRADIENT_TRIANGLE references indices into the TRIVERTEX array (0,1,2).
    val tri = alloc<GRADIENT_TRIANGLE>()
    tri.Vertex1 = 0u
    tri.Vertex2 = 1u
    tri.Vertex3 = 2u

    // Call msimg32.dll GradientFill with GRADIENT_FILL_TRIANGLE mode.
    val ok = GradientFill(
        hdc,
        v,
        3u,
        tri.ptr,
        1u,
        GRADIENT_FILL_TRIANGLE.toUInt()
    )

    // If GradientFill fails, draw an error message for debugging.
    if (ok == 0) {
        val err = GetLastError()
        val msg = "GradientFill failed. GetLastError=$err"
        TextOutW(hdc, 10, 10, msg, msg.length)
    }
}

// Paint handler: compute the client size and draw the triangle to fit.
private fun onPaint(hWnd: HWND?, hdc: HDC?) = memScoped {
    val rc = alloc<RECT>()
    GetClientRect(hWnd, rc.ptr)

    // RECT fields are already integer types in this binding, so no conversion is needed.
    val w = rc.right - rc.left
    val h = rc.bottom - rc.top

    drawTriangle(hdc, w, h)
}

// Window procedure: handle WM_PAINT and WM_CLOSE, otherwise delegate to DefWindowProcW.
private fun WndProc(hWnd: HWND?, uMsg: UINT, wParam: WPARAM, lParam: LPARAM): LRESULT {
    return when (uMsg.toInt()) {
        WM_CLOSE -> {
            // Post WM_QUIT to terminate the message loop.
            PostQuitMessage(0)
            0L
        }

        WM_DESTROY -> {
            // Nothing special here; WM_CLOSE already posts WM_QUIT.
            0L
        }

        WM_PAINT -> {
            // BeginPaint/EndPaint pair is required for WM_PAINT handling.
            memScoped {
                val ps = alloc<PAINTSTRUCT>()
                val hdc = BeginPaint(hWnd, ps.ptr)
                onPaint(hWnd, hdc)
                EndPaint(hWnd, ps.ptr)
            }
            0L
        }

        else -> DefWindowProcW(hWnd, uMsg, wParam, lParam)
    }
}

fun main() {
    memScoped {
        val hInstance = GetModuleHandleW(null)

        // RegisterClassExW sometimes expects a wide string pointer for lpszClassName.
        // Keep this pointer valid by allocating it inside memScoped.
        val classNameW = CLASS_NAME.wcstr.ptr

        // Define and register a WNDCLASSEXW (Unicode) window class.
        val wcex = alloc<WNDCLASSEXW>().apply {
            cbSize = sizeOf<WNDCLASSEXW>().toUInt()
            style = CS_OWNDC.toUInt() // Own a dedicated device context (DC)
            lpfnWndProc = staticCFunction(::WndProc)
            cbClsExtra = 0
            cbWndExtra = 0
            this.hInstance = hInstance
            hIcon = LoadIconW(null, IDI_APPLICATION)
            hCursor = LoadCursorW(null, IDC_ARROW)

            // Use a system-provided brush to avoid unsafe casts (white background).
            hbrBackground = GetSysColorBrush(COLOR_WINDOW)

            lpszMenuName = null
            lpszClassName = classNameW
            hIconSm = LoadIconW(null, IDI_APPLICATION)
        }

        if (RegisterClassExW(wcex.ptr) == 0.toUShort()) {
            MessageBoxW(null, "RegisterClassExW failed", "Error", MB_OK.toUInt())
            return
        }

        // CreateWindowExW may be mapped to a Kotlin-friendly overload that takes String?,
        // so we pass CLASS_NAME / WINDOW_NAME as Kotlin Strings here.
        val hWnd = CreateWindowExW(
            0u,
            CLASS_NAME,
            WINDOW_NAME,
            WS_OVERLAPPEDWINDOW.toUInt(),
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            640,
            480,
            null,
            null,
            hInstance,
            null
        )

        if (hWnd == null) {
            MessageBoxW(null, "CreateWindowExW failed", "Error", MB_OK.toUInt())
            return
        }

        ShowWindow(hWnd, SW_SHOWDEFAULT)
        UpdateWindow(hWnd)

        // Standard message loop.
        val msg = alloc<MSG>()
        while (GetMessageW(msg.ptr, null, 0u, 0u) > 0) {
            TranslateMessage(msg.ptr)
            DispatchMessageW(msg.ptr)
        }
    }
}
