<!DOCTYPE html>
<html>
<head>
  <title>Harmonograph Using WebGPU</title>
  <link rel="stylesheet" type="text/css" href="style_dark.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix.js"></script>
</head>
<body>
<script id="vs" type="x-shader/x-vertex">
[[block]] struct Params {
    modelViewProjectionMatrix : mat4x4<f32>;
    time : f32;
    f1 : f32;
    f2 : f32;
    f3 : f32;
    f4 : f32;
};
[[binding(0), set(0)]] var<uniform> uniforms : Params;

struct VertexInput {
    [[location(0)]] position : vec3<f32>;
};

struct VertexOutput {
    [[builtin(position)]] Position : vec4<f32>;
    [[location(0)]] fragColor : vec4<f32>;
};

[[stage(vertex)]]
fn main(input : VertexInput) -> VertexOutput {
    var output : VertexOutput;

    var A1 : f32 = 0.2;
    var p1 : f32 = 1.0/16.0;
    var d1 : f32 = 0.02;

    var A2 : f32 = 0.2;
    var p2 : f32 = 3.0/2.0;
    var d2 : f32 = 0.0315;

    var A3 : f32 = 0.2;
    var p3 : f32 = 13.0/15.0;
    var d3 : f32 = 0.02;

    var A4 : f32 = 0.2;
    var p4 : f32 = 1.0;
    var d4 : f32 = 0.02;

    var PI : f32 = 3.141592;

    var p : vec3<f32> = input.position;
    p1 = uniforms.time;
    
    var t : f32 = ((p.x/360.0) - 0.5)  * 50.0;
    var x : f32 = A1 * sin(uniforms.f1 * t + PI * p1) * exp(-d1 * t) + A2 * sin(uniforms.f2 * t + PI * p2) * exp(-d2 * t);
    var y : f32 = A3 * sin(uniforms.f3 * t + PI * p3) * exp(-d3 * t) + A4 * sin(uniforms.f4 * t + PI * p4) * exp(-d4 * t);
    var z : f32 = A1 * cos(uniforms.f1 * t + PI * p1) * exp(-d1 * t) + A2 * cos(uniforms.f2 * t + PI * p2) * exp(-d2 * t);

    p.x = x;
    p.y = y;
    p.z = z;
    
    output.Position = uniforms.modelViewProjectionMatrix * vec4<f32>(p, 1.0);
    output.fragColor = vec4<f32>(x + 0.5, y + 0.5, z + 0.5, 1.0);

    return output;
}
</script>

<script id="fs" type="x-shader/x-fragment">
struct FragmentInput {
    [[location(0)]] fragColor : vec4<f32>;
};

struct FragmentOutput {
    [[location(0)]] outColor : vec4<f32>;
};

[[stage(fragment)]]
fn main(input : FragmentInput) -> FragmentOutput {
    var output : FragmentOutput;
    output.outColor = input.fragColor;
    return output;
}
</script>

<canvas id="c" width="465" height="465"></canvas>
<script>
init();
const vertexShaderWGSL = document.getElementById("vs").textContent;
const fragmentShaderWGSL = document.getElementById("fs").textContent;

async function init() {
    const gpu = navigator['gpu']; //
    const adapter = await gpu.requestAdapter();
    const device = await adapter.requestDevice();

    const c = document.getElementById('c');
    c.width = window.innerWidth;
    c.height = window.innerHeight;

    const aspect = Math.abs(c.width / c.height);
    let projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, 45, aspect, 0.1, 1000.0);

    const ctx = c.getContext('gpupresent')
    const swapChainFormat = "bgra8unorm";
    const swapChain = configureSwapChain(device, swapChainFormat, ctx);

    let vShaderModule = makeShaderModule_WGSL(device, vertexShaderWGSL);
    let fShaderModule = makeShaderModule_WGSL(device, fragmentShaderWGSL);

    let baseTime = +new Date;
    let time = 0;
    let f1 = 2;
    let f2 = 2;
    let f3 = 2;
    let f4 = 2;

    let positions = [];
    let MAX = 360;
    for ( let i = 0; i <= MAX; i += 0.1 ) {
        let x = i;
        let y = 0.0;
        let z = 0.0;
        positions = positions.concat([x, y, z]);
    }

    let vertexBuffer = makeVertexBuffer(device, new Float32Array(positions));

    const uniformsBindGroupLayout = device.createBindGroupLayout({
        entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: {
                type: "uniform"
            }
        }]
    });
    const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [uniformsBindGroupLayout] });
    const pipeline = device.createRenderPipeline({
        layout: pipelineLayout,
        vertex: {
            module: vShaderModule,
            entryPoint: 'main',
            buffers: [
                {
                    arrayStride: 3 * 4,
                    attributes: [
                        {
                            // position
                            shaderLocation: 0,
                            offset: 0,
                            format: "float32x3"
                        }
                    ]
                }
            ]
        },
        fragment: {
            module: fShaderModule,
            entryPoint: 'main',
            targets: [
                {
                    format: swapChainFormat
                }
            ]
        },
        primitive: {
            topology: 'line-strip',
            stripIndexFormat: "uint32"
        },
        depthStencil: {
            depthWriteEnabled: true,
            depthCompare: "less",
            format: "depth24plus-stencil8",
        }
    });

    const uniformBufferSize = 4 * 16 + 4 * 5; // 4x4 matrix

    const uniformBuffer = device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const uniformBindGroup = device.createBindGroup({
        layout: uniformsBindGroupLayout,
        entries: [{
            binding: 0,
            resource: {
                buffer: uniformBuffer,
            },
        }],
    });
    
    let rad = 0;
    function getTransformationMatrix() {
        rad += Math.PI * 1.0 / 180.0;
        let viewMatrix = mat4.create();
        mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -2));
        let now = Date.now() / 1000;
        //mat4.rotate(viewMatrix, viewMatrix, 1, vec3.fromValues(Math.sin(now), Math.cos(now), 0));
        mat4.rotate(viewMatrix, viewMatrix, rad, [0, 1, 0]);

        let modelViewProjectionMatrix = mat4.create();
        mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);

        return modelViewProjectionMatrix;
    }

    const depthTexture = device.createTexture({
        size: {
            width: c.width,
            height: c.height,
            depthOrArrayLayers: 1
        },
        format: "depth24plus-stencil8",
        usage: GPUTextureUsage.RENDER_ATTACHMENT
    });
    let render =  function () {
        // uniform float time 
        time = (+new Date - baseTime) / 1000;

        // uniform float f1/2/3/4
        f1 = (f1 + Math.random() / 40) % 10;
        f2 = (f2 + Math.random() / 40) % 10;
        f3 = (f3 + Math.random() / 40) % 10;
        f4 = (f4 + Math.random() / 40) % 10;

        const commandEncoder = device.createCommandEncoder();
        const { uploadBuffer: buffer0 } = updateBufferData(device, uniformBuffer, 0, getTransformationMatrix(), commandEncoder);
        const { uploadBuffer: buffer1 } = updateBufferData(device, uniformBuffer, 4 * 16 +  0, new Float32Array([time]), commandEncoder);
        const { uploadBuffer: buffer2 } = updateBufferData(device, uniformBuffer, 4 * 16 +  4, new Float32Array([f1]), commandEncoder);
        const { uploadBuffer: buffer3 } = updateBufferData(device, uniformBuffer, 4 * 16 +  8, new Float32Array([f2]), commandEncoder);
        const { uploadBuffer: buffer4 } = updateBufferData(device, uniformBuffer, 4 * 16 + 12, new Float32Array([f3]), commandEncoder);
        const { uploadBuffer: buffer5 } = updateBufferData(device, uniformBuffer, 4 * 16 + 16, new Float32Array([f4]), commandEncoder);

        const textureView = swapChain.getCurrentTexture().createView();
        const renderPassDescriptor = {
            colorAttachments: [{
                view: textureView,
                loadValue: {r: 0, g: 0, b: 0, a: 0},
                storeOp: "store"
            }],
            depthStencilAttachment: {
                view: depthTexture.createView(),
                depthLoadValue: 1.0,
                depthStoreOp: "store",
                stencilLoadValue: 0,
                stencilStoreOp: "store"
            }
        };
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setPipeline(pipeline);
        passEncoder.setVertexBuffer(0, vertexBuffer);
        passEncoder.setBindGroup(0, uniformBindGroup);
        passEncoder.draw(positions.length / 3, 1, 0, 0);
        passEncoder.endPass();
        device.queue.submit([commandEncoder.finish()]);
        buffer0.destroy();
        buffer1.destroy();
        buffer2.destroy();
        buffer3.destroy();
        buffer4.destroy();
        buffer5.destroy();
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
}

function configureSwapChain(device, swapChainFormat, context) {
    const swapChainDescriptor = {
        device: device,
        format: swapChainFormat
    };
    return context.configureSwapChain(swapChainDescriptor);
}

function makeShaderModule_WGSL(device, source) {
    let shaderModuleDescriptor = {
        code: source
    };
    let shaderModule = device.createShaderModule(shaderModuleDescriptor);
    return shaderModule;
}

function makeVertexBuffer(device, data) {
    const verticesBuffer = device.createBuffer({
        size: data.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true
    });
    new Float32Array(verticesBuffer.getMappedRange()).set(data);
    verticesBuffer.unmap();
    return verticesBuffer;
}

function makeIndexBuffer(device, data) {
    const indicesBuffer = device.createBuffer({
        size: data.byteLength,
        usage: GPUBufferUsage.INDEX,
        mappedAtCreation: true
    });
    new Uint32Array(indicesBuffer.getMappedRange()).set(data);
    indicesBuffer.pointNum = data.length;
    indicesBuffer.unmap();
    return indicesBuffer;
}

function updateBufferData(device, dst, dstOffset, src, commandEncoder) {
    const uploadBuffer = device.createBuffer({
        size: src.byteLength,
        usage: GPUBufferUsage.COPY_SRC,
        mappedAtCreation: true
    });

    new src.constructor(uploadBuffer.getMappedRange()).set(src);
    uploadBuffer.unmap();

    commandEncoder = commandEncoder || device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(uploadBuffer, 0, dst, dstOffset, src.byteLength);

    return { commandEncoder, uploadBuffer };
}
</script>
<a href="https://github.com/cx20/hello/blob/master/html5/webgpu/3-3.harmonograph.html" target="_blank" style="position:absolute; top:15px; left:15px">View Source</a>
</body>
</html>
